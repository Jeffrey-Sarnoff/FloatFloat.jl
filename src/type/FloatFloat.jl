immutable FloatFloat{T<:SysFloat} <: Real
    hi::T      # high order part (precision T)
    lo::T      # low  order part, extended precision
               # wash away autogenerated constructors 
    FloatFloat{T}(hi::T, lo::T) = new(hi,lo)         # new should not be parameterized
end

# matching an external constructor to the parameterized internal constructor is necessary
FloatFloat{T<:SysFloat}(hi::T, lo::T) = FloatFloat{T}(hi,lo) # the RHS must be parameterized

# more robust external construction
FloatFloat{T<:SysFloat}(hi::T) = FloatFloat(hi,zero(T)) # RHS should not be parameterized

# define explicit conversions for faster immutable type construction
convert{T<:SysFloat}(::Type{FloatFloat{T}}, hi::T, lo::T) = FloatFloat{T}(hi, lo)
convert{T<:SysFloat}(::Type{FloatFloat{T}}, hi::T)        = FloatFloat{T}(hi, zero(T))

# define complementary conversions
convert{T<:SysFloat}(::Type{T}, ff::FloatFloat{T}) = ff.hi
convert(::Type{Float64}, ff::FloatFloat{Float32})  = convert(Float64,ff.hi)
convert(::Type{Float32}, ff::FloatFloat{Float64})  = convert(Float32,ff.hi)

# define interconversion
convert(::Type{FloatFloat{Float64}}, x::FloatFloat{Float32}) = 
  FloatFloat{Float64}(x.hi) + FloatFloat{Float64}(x.lo)


# foundational promotions
promote_rule{T<:SysFloat,S<:StdFloat}(::Type{FloatFloat{T}}, ::Type{S}) = FloatFloat{T}
promote_rule{T<:SysFloat,S<:StdInt}(::Type{FloatFloat{T}}, ::Type{S}) = FloatFloat{T}
promote_rule{T<:SysFloat,S<:StdFloat}(::Type{FloatFloat{T}}, ::Type{Rational{S}}) = FloatFloat{T}
promote_rule(::Type{FloatFloat{Float64}}, ::Type{FloatFloat{Float32}}) = FloatFloat{Float64}


# a type specific hash function helps the type to 'just work'
const hash_floatfloat_lo = (UInt === UInt64) ? 0x086540d7a5325bc3 : 0x5acda43c
const hash_0_floatfloat_lo = hash(zero(UInt), hash_floatfloat_lo)
hash{T<:Real}(z::FloatFloat{T}, h::UInt) = 
    hash(z.hi, (h $ hash(z.lo, hash_floatfloat_lo) $ hash_0_floatfloat_lo))
